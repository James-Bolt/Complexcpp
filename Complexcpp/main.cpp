#include <iostream>
#include <fstream>
#include <clocale>                                   // дл€ русского €зыка, если вам очень нужно
#include "complex.h"

using namespace std;

int main() {
  setlocale(LC_CTYPE, "Russian");

  Complex c0;              // пример использовани€ конструткора по умолчанию
  Complex c1(4.3, 2.5);    // примеры использовани€ конструктора инициализации
  Complex c2(1.5, 2.1);    
  Complex c3(c2);          // пример использовани€ конструктора копировани€
  Complex c4(-4.9);        // пример использовани€ конструктора преобразовани€ типа

  // указатели на комплексные числа (в конце нужно удал€ть деструтором)
  Complex *pc0 = new Complex();                        // по умолчанию
  Complex *pc1 = new Complex(4.3, 2.5);                // инициализаци€
  Complex *pc3 = new Complex(c2);                      // копировани€
  Complex *pc4 = new Complex(-4.9);                    // преобразовани€ типа

  // пример использовани€ функции вывода
  cout << "„исло, созданное конструктором по умолчанию: с0 = ";
  c0.output();
  cout << "„исло, созданное конструктором инициализации: с1 = ";
  c1.output();
  cout << "„исло, созданное конструктором инициализации: с2 = ";
  c2.output();
  cout << "„исло, созданное конструктором копировани€: с3 = ";
  c3.output();
  cout << "„исло, созданное конструктором преобразовани€ типа: с4 = ";
  c4.output();

  Complex c5;
  c5 = c2;                                            // применение перегруженой операции присваивани€
  cout << "–езультат применени€ присваивани€ c2 новой переменной: с5 = ";
  c5.output();

  Complex c6, c7;
  if (c6 == c7) {                                    // пример на применение перегруженой операции сравнени€ (==) сделать самим
    cout << "”спешно!" << endl;
  }
   
  Complex c8;
  c8 = c2.Add(c1);                                    // применение функции сложени€
  cout << "–езультат сложени€ функцией сложени€: с8 = c2 + c1 = ";
  c8.output();

  Complex c9;
  c9 = c2 + c1;                                       // применение перегруженой операции сложени€
  cout << "–езультат сложени€ с помощью перегруженного оператора: c9 = c2 + c1 = ";
  c9.output();


  
   // ѕримеры на применение перегруженых операций вычитани€ (-), умножени€ (*), делени€ (/) сделать самим

  Complex c10;
  c10 = c1 - c2;                                      
  cout << "–езультат вычитани€ с помощью перегруженного оператора: c10 = c1 - c2 = ";
  c10.output();

  Complex c11;
  c11 = c1 * c2;
  cout << "–езультат умножени€ с помощью перегруженного оператора: c11 = c1 * c2 = ";
  c11.output();

  Complex c12;
  c12 = c1 / c2;
  cout << "–езультат делени€ с помощью перегруженного оператора: c12 = c1 / c2 = ";
  c12.output();

  // вызовы деструктора дл€ указателей
  delete pc0;
  delete pc1;
  delete pc3;
  delete pc4;

  system("pause");
  return 0;                                         // <---- в —++ этот return можно не писать вообще
}
